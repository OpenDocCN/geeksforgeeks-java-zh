# Java 组播(多次打字)谜题

> 原文:[https://www . geesforgeks . org/Java-多播-类型转换-多次-谜题/](https://www.geeksforgeeks.org/java-multicasting-typecasting-multiple-times-puzzle/)

找到程序的输出

```java
public class Multicast {
    public static void main(String[] args) {
    System.out.println((int) (char) (byte) -1);
    }
}
```

无论你怎么看，这个程序都很混乱。它从 int 值-1 开始，然后将 int 转换为字节，然后转换为字符，最后转换回 int。第一次转换将值从 32 位缩小到 8 位，第二次转换将值从 8 位扩大到 16 位，最后一次转换将值从 16 位扩大回 32 位。价值最终会回到起点吗？如果你运行这个程序，你会发现它不是。它打印 **65535**
让我们一步一步了解这个:-
**1。**程序的行为关键取决于强制转换的符号扩展行为。Java 使用二进制补码二进制算法，因此 int 值-1 设置了所有 32 位。

**2。**从 int 到 byte 的转换很简单。它执行一个缩小的原语转换，简单地砍掉除低阶 8 位之外的所有位。这就留下了一个字节值，所有 8 位都置位，仍然代表-1。

**3。**从字节到字符的转换比较复杂，因为字节是带符号的**类型，字符是无符号的**。在保留数值的情况下，通常可以从一个整数类型转换为一个更宽的整数类型，但是不能将负字节值表示为字符。因此，从字节到字符的转换不被认为是扩展原语转换，而是扩展和收缩原语转换:字节转换为 int，int 转换为 char。
所有这些听起来可能有点复杂。幸运的是，有一个简单的规则描述了从较窄的整数类型转换到较宽的整数类型时的符号扩展行为:如果原始值的类型是有符号的，则执行符号扩展；如果它是一个字符，则零扩展，而不管它被转换成什么类型。知道了这条规则，解谜就容易了。因为字节是有符号类型，所以在将字节值-1 转换为字符时会出现符号扩展。得到的字符值设置了所有 16 位，因此它等于 65，535。****

******4。**从 char 到 int 的强制转换也是一个扩展的原语转换，所以规则告诉我们执行零扩展而不是符号扩展。
得到的 int 值是 65535，这正是程序打印的结果。****

******参考文献:**
爪哇困惑者图书****

****本文由 **Shubham Juneja** 供稿。如果你喜欢 GeeksforGeeks 并想投稿，你也可以使用[contribute.geeksforgeeks.org](http://www.contribute.geeksforgeeks.org)写一篇文章或者把你的文章邮寄到 contribute@geeksforgeeks.org。看到你的文章出现在极客博客主页上，帮助其他极客。****

****如果你发现任何不正确的地方，或者你想分享更多关于上面讨论的话题的信息，请写评论。****